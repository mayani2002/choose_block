## DIFFICULTY:

Medium

## PREREQUISITES:

Array or vector, Two-pointers (Set/Map/Frequency in other approachs)

## PROBLEM STATEMENT:

Rohan has arranged $N$ wooden block in a line and has numbered them from $1$ to $N$ to identify them correctly. He has $M$ different paints where every color is given a code number from $1$ to $M$. Rohan decides to paint each block in a particular color where he might use all $M$ colors ( $ie.$ $C_1,C_2,â€¦,C_m$ ) to paint the blocks or might miss out on few colors. There can be one or more than one block of same color code.

He gives you a challenge where you have to select the longest contiguous subsegment of the blocks such that there is at least one color among all $M$ colors which does not occur in that subsegment of blocks. 

## EXPLANATION

The above question we have to find the maximum length of a subarray which can be generated by comparing difference of the start and end point of all possible subarrays and taking max value as the answer. To maintain the start and end position of subarray in the main array of $N$ blocks, we will use 2 pointers $j$ and $i$ where $j$ will be the starting point and $i$ will be the end point of the subarray which will be incremented accordinding to different conditions.

 A variable $color\_count$ will be used to keep an acount of number of colors in the subarray, during the incrementation of $i$. At any step if $color\_count$ is equal to $M$, $i$ won't be incremented further and length of the subarray will be calculated (Since we need at max $M-1$ colors in the sub array). If the length is greater than the length of previous subarrays, it will be stored as an answer. To get a new subarray, the start pointer $j$ will be incremented until 1 color is eliminated from the subarray which makes total $M-1$ colors in the subarray. To get the max length of subarray with $M-1$ colors, $i$ will be incremented until $color\_count$ becomes $M$. This way we will get a new subarray. But we don't know how how many times $j$ (starting point) is incremented as colors can occur repeatedly any number of time, in any order. To maintain the frequency of the occurence of a particular color in the subarray of block, another array or vector named $freq$ of length $M+1$ will be used, where index will be considered color code and the value at that index  will be the count of blocks of that color code in the subarray. So every time $j$ is incremented, a count of color in the $j^{th}$ position of $freq$ array is reduced by 1 depicting the removal of one block from the sub array at starting position.

 The whole procedure will be repeated until $i$ of that test case is less than $N$. At the end of every test case the max length of subarray (which satisfies the condition) will be stored.

**C++ Code (solution)**

    #include <iostream>
    #include<vector>
    using namespace std;

    int main()
    {
        int t;
        cin>>t;
        while(t--)
        {
            int n,m;
            cin>>n>>m;
            vector<int> arr(n),freq(m+1,0);
            int ans=0,color_count=0;
            for(int i=0;i<n;i++)
                cin>>arr[i];
            int i=0,j=0;
            while(i<n)
            {
                freq[arr[i]]++;
                if(freq[arr[i]]==1)
                {
                    color_count++;
                }
                if(color_count==m)
                {
                    ans=max(ans,i-j);
                    while(color_count==m)
                    {
                        freq[arr[j]]--;
                        if(freq[arr[j]]==0)
                            color_count--;
                        j++;
                    }
                }
                i++;
            }
            cout<<max(ans,i-j)<<endl;
        }
    }

## TIME COMPLEXITY:

$O(NlogN)$ or $O(N)$ depending on implementation.